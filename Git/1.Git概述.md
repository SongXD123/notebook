# 1.Git概述

### 1.1 Git历史

Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众多的参与者（Git的产生和Linux内核有很大关系，Git和Linux作者是同一人）。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个<u>**专有的分布式版本控制系统 BitKeeper**</u> 来管理和维护代码。

到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 



他们对新的系统制订了若干目标：

* 速度

* 简单的设计（设计和用户使用要足够简单）

* 对非线性开发模式的强力支持（允许成千上万个并行开发的分支）

* **完全分布式**（与SVN的最大区别）

* 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）

### 1.2 Git与SVN对比

SVN是==集中式的版本控制系统==，版本库是集中放在中央服务器的（C/S结构软件），而开发人员工作时，用的都是自己的电脑，所有首先要从中央服务器下载最新的代码，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。

![image-20210305190539471](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210305190539471.png)

集中式版本控制工具的缺点

* 服务器单点故障
* 容错性差（与第一个有关系，正是由于单点故障，所以一旦服务器出问题，整个工作环境就不可用了）



Git是==布式版本控制系统==（Distributed Version Control System，简称 ==DVCS==） ，分为两种类型的仓库：==本地仓库==和==远程仓库==。



* 本地仓库：是在开发人员自己电脑上的Git仓库

* 远程仓库：是在远程服务器上的Git仓库

![image-20210305191305721](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210305191305721.png)

图的解释;

* Commit命令：将代码提交到本地仓库，此时其他开发人员是看不到的
* PUSH命令：将本地仓库的代码==推送==（上传）到远程仓库
* PULL命令：从远程仓库==拉取==（下载）代码到本地

* Clone命令：将远程仓库==克隆==（复制）到本地



本地：可以进行版本管理（提交，查看日志，恢复数据）



### 1.3 Git工作流程



工作区：目前可以先认为是自己电脑上的文件夹

暂存区：



工作流程如下：

1. 从远程仓库中克隆代码到本地仓库
2. 从本地仓库中checkout（检出）代码然后进行修改（检出到工作区，目前可以先认为是自己电脑上的文件夹）
3. 在提交前需要先将代码提交到暂存区
4. 提交到本地仓库。本地仓库中保存修改的各个历史版本
5. 修改完成后，需要和团队成员共享代码时，将代码push到远程仓库、
6. CLONE操作只需要一次，之后如果想要从远程仓库下载代码，拉取(PULL)代码到工作区即可



![image-20210305191803488](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210305191803488.png)



### 1.4 Git安装与下载

* Git GUI：Git提供的图形界面工具
* Git Bash：Git提供的命令行工具



# 2. Git代码托管服务

### 2.1 常用的Git代码托管服务

前面我们已经知道了Git中存在两种类型的仓库，即本地仓库（自己电脑上的Git仓库）和远程仓库（远程服务器上的Git仓库）。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些==代码托管服务==来实现，其中比较常用的有GitHub、码云、GitLab等。



* **GitHub**：（ 地址：https://github.com/ ）是一个**面向开源及私有软件项目**的托管平台，因为**只支持Git** 作为唯一的版本库格式进行托管，故名GitHub
* **码云**：（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快
* **GitLab**：（地址： https://about.gitlab.com/ ）是一个用于==仓库管理系统==的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务

### 2.2 注册

### 登录并创建Git远程仓库

![image-20210306131114396](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306131114396.png)

![image-20210306131159138](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306131159138.png)

初始化仓库：

* 使用README文件初始化仓库
* 

创建完成

![image-20210306131435413](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306131435413.png)

每个Git远程仓库都会对应一个网络地址：https://github.com/SongXD123/myRepo1.git

当前仓库为空

# 3.Git常用命令

本节有如下命令和概念

* 环境配置：通过Git相关命令

* 获取Git仓库

* 工作目录、暂存区以及版本库概念：

* Git工作目录下文件的两种状态：未跟踪状态、已跟踪状态

* 本地仓库操作

* 远程仓库的使用

* 分支

* 标签

### 3.1 环境配置

当安装Git后，首先要做的事情就是==设置用户名称和Email地址==（当前是谁）。这是非常重要的，因为每次Git提交都会使用该用户信息

注意：这里的用户名称和Email地址与远程仓库（码云、GitHub）是没有关系的，之前GitHub注册的用户名和地址是为了操作远程仓库，推送和克隆都需要GitHub账号；而这里只是设置个人信息，该个人信息不是用作认证的，只是标识你是谁，因此可以任意设置



* 设置用户信息
  * git config --global user.name "itcast"
    * global表示全局
  * git config --global user.email "hello@itcast.cn"
    * Email地址也会不进行校验，因此是可以任意写的
* 查看配置信息
  * git config --list
  * git config user.name
* 通过上面的命令设置的信息会保存在==~/.gitconfig==文件中

### 3.2 获取Git仓库

要使用Git对我们的代码进行版本控制，首先要获得Git仓库

获取Git仓库通常有两种方式

* 在本地初始化一个Git仓库
* 从远程仓库中克隆

#### 3.2.1 在本地初始化一个Git仓库

步骤如下：

* 在电脑的任意位置创建一个空目录（例如repo1）作为我们的本地Git仓库

*  进入这个目录中，点击右键打开Git bash窗口

* 执行命令git init

* 如果在当前目录中看到.git文件夹，说明创建成功

  ![image-20210306134224230](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306134224230.png)

#### 3.2.2 从远程仓库克隆

可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地

命令形式为：git clone 远程Git仓库地址 

![image-20210306134525973](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306134525973.png)

### 3.3 工作目录、暂存区以及版本库概念

**版本库**：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多==配置信息、日志文件和文件版本信息==

**工作目录（工作区）**：==包含,git文件夹的目录==就是工作目录，主要用于存放开发的代码

**暂存区**：.git文件夹中有很多文件，其中有一个==index文件（二进制文件）==就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方，如要提交修改后的文件，前提是将修改的文件的改变存放到暂存区，只有从暂存区里面才能提交到版本库，让git进行版本管理

![image-20210306135426946](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306135426946.png)

* git add：将改变的内容提交到暂存区
* git commit：将修改的内容提交到版本库

### 3.4 Git工作目录下文件的两种状态

Git工作目录下的文件存在两种状态：

* untracked未跟踪（未被纳入版本控制，没有被Git进行版本管理）
* tracked已跟踪（被纳入版本控制，被Git进行版本管理）
  * Unmodified：未修改状态
  * Modified：已修改状态
  * Staged：已暂存状态，修改完成后，只有通过git add将修改的文件添加到暂存区，才成为已修改状态
* 这些文件的状态会随着我们执行Git的命令发生改变

### 3.5 本地仓库操作

**git status查看文件状态**

![image-20210306140423257](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306140423257.png)

* 当前处于main分支
* 已被跟踪但还未被修改的不会提示

也可以通过==git status -s==使输出更加简洁

![image-20210306140548106](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306140548106.png)







**git add将未跟踪的文件加入暂存区**

![image-20210306140955309](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306140955309.png)

将新创建的文件加入暂存区后查看文件状态

![image-20210306141141812](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306141141812.png)







**git reset 将暂存区的文件取消暂存**

![image-20210306141314936](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306141314936.png)

此时回到未跟踪

![image-20210306141513176](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306141513176.png)







**git commit将暂存区的文件修改提交到本地仓库**

git commit -m message

* 必须有**-m**参数，表示提交时需要提交日志信息，其实是一个字符串
  * 如果不加-m参数，会默认打开编辑器，要求我们将日志信息写到vim编辑器中
* 会将暂存区中所有文件提交，==必须先提交到暂存区==
* message是一个字符串
* 提交后变为**==已跟踪后的未修改状态==**

![image-20210306141831512](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306141831512.png)







**git rm删除文件**

git rm filename

只是将工作区中文件删除，而并没有提交，因此本地仓库中还是有该文件的

* 这个命令必须在**提交到版本库以后才能执行的**，否则
  * 如果文件没有提交到版本库，Git是不会发现的，并报错：fatal: pathspec ==filename== did not match any files
  * 如果提交到暂存区，是无法删除的，并报错：error: the following file has changes staged in the index:    ==filename==
  * 如果文件与版本库中不一致，就删除不了，除非强制删除：

![image-20210306143520871](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306143520871.png)

* rm操作==默认添加到暂存区==，可以直接用**commit**提交
* 选中文件删除：**没有提交到暂存区的意思**，所以还需用git add将删除的文件加到暂存区
* ==**not staged for commit**==：没有提交到暂存区的意思







**==将文件添加至忽略列表==**

一般我们总会有些文件**无需纳入Git 的管理（如日志文件，.class文件）**，希望管理的是源代码等，**也不希望它们总出现在未跟踪文件列表**。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式（**#号为注释**；**!**表示取反，表示除外；。下面是一个示例：

> \# no .a files
>
> *.a
>
> \# but do track lib.a, even though you're ignoring .a files above
>
> !lib.a
>
> \# only ignore the TODO file in the current directory, not subdir/TODO
>
> /TODO
>
> \# ignore all files in the build/ directory
>
> build/
>
> \# ignore doc/notes.txt, but not doc/server/arch.txt
>
> doc/*.txt
>
> \# ignore all .pdf files in the doc/ directory
>
> doc/**/*.pdf

**touch .gitignore**







+==**git log查看日志记录**==

 进入vim编辑器，回车下一行，q退出

![image-20210306145325288](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210306145325288.png)



### 3.6 远程仓库操作

前面执行的命令操作都是针对的本地仓库，本章节我们会学习关于远程仓库的一些操作，具体包括：

* 查看远程仓库

* 添加远程仓库

* 从远程仓库克隆

* 移除无效的远程仓库

* 从远程仓库中抓取与拉取

* 推送到远程仓库



**==查看远程仓库==**

如果想查看**已经配置的远程仓库服务器**，可以运行**git remote**命令。它会列出指定的每一个远程服务器的简写。

![image-20210307155347397](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210307155347397.png)

如果已经克隆了远程仓库，那么至少应该能看到origin，这是Git克隆的服务器的默认名字

* origin表示本地仓库和哪个远程仓库建立了关联



如果想要看得更详细些，可以通过**git remove -v**：

![image-20210307155632736](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210307155632736.png)

* fetch表示可以从这个地址抓取
* push表示本地开发得代码可以推送到远程仓库。
* fetch==push表示本地仓库和远程仓库建立了关联关系，既可以从远程仓库抓取代码，也可以将本地代码推送到远程仓库。而该仓库名字为origin
* 因此当前本地仓库是克隆来的，所以默认配置远程仓库名origin
* **如果当前本地仓库没有和任何远程仓库建立关联关系，则git remote命令不会显示任何东西**
* 查看更详细的信息：**git remote show origin**
  * 当前分支：master（HEAD branch）
  * 远程分支：master tracked，表示当前master分支和远程master分支有追踪关系（关联关系）
* ![image-20210307160840355](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210307160840355.png)

 





**==添加远程仓库==**

对于非克隆而来的本地仓库，可以运行**git remote add <shortname> <url>**添加一个新的远程Git仓库，同时可以指定一个可以引用的简写（

* 一般建议远程仓库和本地仓库名称保持一致

* 一般shortname建议**origin**

  ![image-20210307161703648](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210307161703648.png)

  * 顺序
    * git remote add <shortname> <url>
    * git remove查看

* 一个本地仓库**可以添加多个远程仓库**，指定不同的<shortname>







**==从远程仓库克隆==**

如果你想获得一份已经存在了的 Git 仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是==**该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等），而不仅仅是复制工作所需要的文件**==。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的<u>**每一个文件的每一个版本都将被拉取下来**</u>。

克隆仓库的命令格式是 **git clone [url]**







**==移除无效的远程仓库==**

如果因为一些原因想要移除一个远程仓库，可以使用==**git remote rm <name>**== 

注意：此命令只是**从本地移除远程仓库的记录（关联关系）**，如之前的origin，并**不会真正影响到远程仓库**







**==从远程仓库抓取与拉取==**

* ==**git fetch**==是从远程仓库中获取最新版本到本地仓库，**不会自动merge**

  * git fetch <shortname> <branch>

  * 默认：git fetch = git fetch origin master

  * 抓取完成后，会将文件抓取到本地仓库（**.git/objects/**），是以二进制形式存放，但是没有合并到工作区来，所以工作区中并没有这些文件

  * 所以还需要手动合并：**==git merge origin/master==**(shortname/branch)

    ![image-20210307164514247](https://github.com/SongXD123/notebook/raw/main/Git/images/image-20210307164514247.png)

  * 

* **==git pull==**是从远程仓库获取最新版本并**merge到本地仓库**

  * 拉取的只是有区别的文件，相同的文件拉取不到

* 可能的报错

  * 如果当前本地仓库不是从远程仓库，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库中拉取文件的时候会报错（fatal:refusing to merge unrelated hostories)，解决此问题可以在git pull命令后面加上参数**==--allow-unrelated-histories==**，也就是不能合并的错误
  
* 修改并上传单个文件

  * 首先提交到本地仓库：
    * git add filename
    * git commit
    * 或 git commit -a -m message，先提交到暂存区，再提交
  * git push origin master



# 注意

1. git status下中文文件名显示Unicode码

   git config --global core.quotepath false

2. 解决git 错误error: failed to push some refs to......

   * **办法1：**先拉下来，会自动合并的（不用操心）

     命令：git pull origin master

   * **办法2：**可以通过如下命令进行代码合并

     命令：git pull --rebase origin master  (我的成功解决是方法2)

   * **最后：**再执行语句 git push 即可完成代码上传到github

     命令：git push -u origin master

3. 